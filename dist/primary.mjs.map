{"version":3,"sources":["../src/primary.ts"],"sourcesContent":["import { type ChildProcess, fork } from \"node:child_process\";\nimport cluster, { type Worker } from \"node:cluster\";\nimport type { ShutdownManager } from \"./async-shutdown\";\nimport type { NormalizedThartOptions, WorkerFunction } from \"./types\";\n\nexport async function startPrimary(\n  options: NormalizedThartOptions,\n  manager: ShutdownManager,\n): Promise<void> {\n  if (!cluster.isPrimary) {\n    throw new Error(\"Can not invoke `startPrimary` outside of `primary`\");\n  }\n  if (options.primary) await options.primary.start();\n  const childProcesses: ChildProcess[] = [];\n  manager.addListener(async () => {\n    try {\n      await waitForWorkersWithTimeout(options.grace, childProcesses);\n    } finally {\n      if (options.primary?.stop) await options.primary.stop();\n      process.exitCode = 0;\n    }\n  });\n  for (let i = 0; i < options.worker.length; i++) {\n    spawnWorker(i, options.worker[i], childProcesses);\n  }\n}\n\nexport function spawnWorker(\n  i: number,\n  workerConfig: WorkerFunction,\n  childProcesses: ChildProcess[],\n): void {\n  if (workerConfig.type === \"childProcess\") {\n    const childProcess = fork(process.argv[1], [], {\n      env: {\n        ...process.env,\n        WORKER_ID: i.toString(),\n        CHILD_PROCESS_ID: childProcesses.length.toString(),\n        WORKER_TYPE: \"childProcess\",\n      },\n    });\n    childProcesses.push(childProcess);\n  } else if (workerConfig.type === \"cluster\") {\n    cluster.fork({ WORKER_ID: i.toString(), WORKER_TYPE: \"cluster\" });\n  } else {\n    throw new Error(`Invalid worker type: ${workerConfig.type}`);\n  }\n}\n\n/**\n * Waits for all workers and child processes to terminate within a specified grace period.\n *\n * This function periodically checks the status of cluster workers and child processes.\n * It resolves when all workers and child processes have terminated.\n * If the grace period expires before all workers and child processes have terminated,\n * it forcibly terminates them and rejects with an error.\n *\n * @param {number} grace - The maximum time (in milliseconds) to wait for workers and child processes to terminate.\n * @param {ChildProcess[]} childProcesses - An array of child processes to monitor.\n * @returns {Promise<void>} A promise that resolves when all workers and child processes have terminated,\n *                          or rejects if the grace period expires.\n * @throws {Error} If the grace period expires before all workers and child processes terminate.\n */\nexport function waitForWorkersWithTimeout(\n  grace: number,\n  childProcesses: ChildProcess[],\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    const startTime = Date.now();\n    const intervalId = setInterval(() => {\n      const workers = getConnectedWorkers();\n      // really this triggers when the cluster workers array is empty but we keep the isDead\n      // check for the case where cluster.workers returns a dictionary containing dead workers\n      // (though I have never observed this to be the case)\n      const allWorkersDead = workers.every(\n        (worker) => !!worker && worker.isDead(),\n      );\n      const allChildProcessesDead = childProcesses.every(\n        // need the `exitCode` check to ensure we count processes that exited due to:\n        // 1) empty event loop\n        // 2) process.exit invocations\n        (cp) => cp.signalCode !== null || cp.exitCode !== null,\n      );\n\n      if (allWorkersDead && allChildProcessesDead) {\n        clearInterval(intervalId);\n        resolve();\n      }\n\n      if (Date.now() - startTime >= grace) {\n        console.error(\"Forcibly terminating workers after grace period\");\n        clearInterval(intervalId);\n        workers.forEach((worker) => worker?.kill());\n        childProcesses.forEach((cp) => cp.kill());\n        reject(new Error(\"Forcibly terminated workers after grace period\"));\n      }\n    }, 100);\n  });\n}\n\n/**\n * @returns An array of active workers in the cluster if invoked in the primary process, else an empty array.\n */\nfunction getConnectedWorkers(): (Worker | undefined)[] {\n  return Object.values(cluster.workers ?? {});\n}\n"],"mappings":";AAAA,SAA4B,YAAY;AACxC,OAAO,aAA8B;AAIrC,eAAsB,aACpB,SACA,SACe;AACf,MAAI,CAAC,QAAQ,WAAW;AACtB,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AACA,MAAI,QAAQ,QAAS,OAAM,QAAQ,QAAQ,MAAM;AACjD,QAAM,iBAAiC,CAAC;AACxC,UAAQ,YAAY,YAAY;AAC9B,QAAI;AACF,YAAM,0BAA0B,QAAQ,OAAO,cAAc;AAAA,IAC/D,UAAE;AACA,UAAI,QAAQ,SAAS,KAAM,OAAM,QAAQ,QAAQ,KAAK;AACtD,cAAQ,WAAW;AAAA,IACrB;AAAA,EACF,CAAC;AACD,WAAS,IAAI,GAAG,IAAI,QAAQ,OAAO,QAAQ,KAAK;AAC9C,gBAAY,GAAG,QAAQ,OAAO,CAAC,GAAG,cAAc;AAAA,EAClD;AACF;AAEO,SAAS,YACd,GACA,cACA,gBACM;AACN,MAAI,aAAa,SAAS,gBAAgB;AACxC,UAAM,eAAe,KAAK,QAAQ,KAAK,CAAC,GAAG,CAAC,GAAG;AAAA,MAC7C,KAAK;AAAA,QACH,GAAG,QAAQ;AAAA,QACX,WAAW,EAAE,SAAS;AAAA,QACtB,kBAAkB,eAAe,OAAO,SAAS;AAAA,QACjD,aAAa;AAAA,MACf;AAAA,IACF,CAAC;AACD,mBAAe,KAAK,YAAY;AAAA,EAClC,WAAW,aAAa,SAAS,WAAW;AAC1C,YAAQ,KAAK,EAAE,WAAW,EAAE,SAAS,GAAG,aAAa,UAAU,CAAC;AAAA,EAClE,OAAO;AACL,UAAM,IAAI,MAAM,wBAAwB,aAAa,IAAI,EAAE;AAAA,EAC7D;AACF;AAgBO,SAAS,0BACd,OACA,gBACe;AACf,SAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC5C,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,aAAa,YAAY,MAAM;AACnC,YAAM,UAAU,oBAAoB;AAIpC,YAAM,iBAAiB,QAAQ;AAAA,QAC7B,CAAC,WAAW,CAAC,CAAC,UAAU,OAAO,OAAO;AAAA,MACxC;AACA,YAAM,wBAAwB,eAAe;AAAA;AAAA;AAAA;AAAA,QAI3C,CAAC,OAAO,GAAG,eAAe,QAAQ,GAAG,aAAa;AAAA,MACpD;AAEA,UAAI,kBAAkB,uBAAuB;AAC3C,sBAAc,UAAU;AACxB,gBAAQ;AAAA,MACV;AAEA,UAAI,KAAK,IAAI,IAAI,aAAa,OAAO;AACnC,gBAAQ,MAAM,iDAAiD;AAC/D,sBAAc,UAAU;AACxB,gBAAQ,QAAQ,CAAC,WAAW,QAAQ,KAAK,CAAC;AAC1C,uBAAe,QAAQ,CAAC,OAAO,GAAG,KAAK,CAAC;AACxC,eAAO,IAAI,MAAM,gDAAgD,CAAC;AAAA,MACpE;AAAA,IACF,GAAG,GAAG;AAAA,EACR,CAAC;AACH;AAKA,SAAS,sBAA8C;AACrD,SAAO,OAAO,OAAO,QAAQ,WAAW,CAAC,CAAC;AAC5C;","names":[]}